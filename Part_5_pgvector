# Part 5 – pgvector

pgvector extends PostgreSQL by introducing a **vector data type** that allows storage of high-dimensional embeddings (e.g., 768‑dimensional vectors from OpenAI or Hugging Face) directly within tables. It supports a variety of **similarity search operators**—including Euclidean (`<->`), cosine (`<=>`), inner product (`<#>`), L1/Manhattan (`<+>`), and metrics like Hamming and Jaccard for binary or sparse vectors—and offers approximate nearest‑neighbor **indexing methods** such as Inverted File (IVF) and Hierarchical Navigable Small World (HNSW) graphs. All of these capabilities integrate natively with PostgreSQL’s features—ACID compliance, point‑in‑time recovery, complex joins, and filters—enabling hybrid relational and embedding queries in a single system.

The **pgvector‑python** library provides seamless integration with Python applications, supporting Django, SQLAlchemy, SQLModel, Psycopg 2/3, asyncpg, pg8000, and Peewee. Developers can define models with `VectorField` attributes, insert and retrieve embeddings, and perform similarity searches using familiar ORM query patterns, making it straightforward to incorporate vector‑based retrieval into existing Python‑based data pipelines.

By co‑locating structured financial data and unstructured embeddings in PostgreSQL, pgvector enables **unified data management** and **enhanced search capabilities**, allowing semantic queries over both tabular records and document embeddings. Leveraging PostgreSQL’s scalability alongside pgvector’s indexing techniques ensures **performance and scalability** even with large vector datasets. The library’s tight ORM integrations also drive **ease of integration**, reducing development friction when adding semantic search to Python applications.

That said, pgvector may not match the throughput or latency of specialized vector databases (e.g., Pinecone, Milvus) in extremely large‑scale or real‑time scenarios. Building and maintaining **high‑dimensional indexes** can be resource‑intensive, requiring careful planning to balance search speed with system resources. Additionally, teams unfamiliar with vector similarity concepts may face a **learning curve** as they master distance metrics, index types, and hybrid query design within PostgreSQL.
